# Why Learn C?

> There are an awful lot of programming languages available right now -- everything from the extremely high level (such as Visual Basic) to the low level power of assembly, and a good variety of specialized options in between (Perl, Ruby, and Python are good choices for many tasks). Java has also become quite the hot programming language for some tasks, in part because of its large API and in part because the virtual machine provides some elements of security. (Garbage collection is another nice feature and can make programmers much more efficient.) 
[Why 1](http://www.cprogramming.com/whyc.html)

### why C should be your first programming language.

1.I believe nobody can learn C++ or Java directly. To master these languages you need to have a strong concept of programming element such as polymorphism, classes, inheritance etc. Simple question is how you can learn such complicated concepts when you don't even know about the basic elements such as block functions. C is a language which begins from scratch and it has foundational concepts on which today concepts stand on.

2.It is language on which C++ is based on, hence C# also derive its origin from the C. Java is also a distant cousin of C and share the same programming concept and syntax of C. *These are the most dominant languages in the world and all are based on C*. **To rock the world through them you must get rocking with C**.

3.C++, Java, and C # make use of **OOP** (Object Oriented Programming). Not all programs need it even though it is a powerful tool. Such programs are still written in C.

4. When ever it comes to performance (speed of execution), C is unbeatable.

5.Major parts of the Windows, Unix and Linux are still written in C. So if you want program these OS or create your own you need to know C.

6.Device drivers of new devices are always written in C. The reason is that C provides you access to the basic elements of the computer. It gives you direct access to memory of your CPU through pointers. It allows you to manipulate and play with bits and bytes.

7.Mobiles, Palmtops, PDA's etc are gaining popularity every second. Also appliances such as T.V., Refrigerators, and Microwaves etc. are becoming an integral part of our daily needs. You may not know but they have a CPU with them which do need programming and the software's written for them are known as embedded system programs. These programs have to be fast in execution but also have a very little memory. No question why C is ideally suited for embedded system programming.

8.You must have played games on your PC. Even today these astounding 3D games use C as their core. Why? The simple reason who will play the game when it takes a lot of time fire a bullet after you have given command from the console. The reply to the command should be damn prompt and fast. Reply in 1 Nano second is an outstanding game; Reply in 10 Nano seconds is crap. Even today there is no match for C.

9. C is a middle level language. There are three types of language - High Level, Middle Level & Low Level. High level languages are user oriented, giving faster development of programs, example is BASIC. Low level languages are machine oriented; they provide faster execution of programs. C is a middle level language because it combines the best part of high level language with low level language. It is both user and machine oriented and provides infinite possibilities.

10.Last but not least it is a block structured language. The first symbol of a modern language is that it is block structured. Each code exists in separate block and is not known to code in other block providing easy means of programming and minimizing the possibilities of undesirable side effects. C is designed from the base to top to be a block structured language. Many older languages, most popular being BASIC tried to introduce this concept but their short coming can never fulfilled as they were never built along these line. 

I think I have given all reason I know why c should be your first programming language. One thing is for sure that there no other language which more reliable, simple and easy to use.

---

### Advantages

However, I do think there are advantages to learning C first over C++ or Java. When you work in languages like Java, C# and even Python, you immediately start moving away from learning the fundamentals of a programming language and you start learning associated libraries and frameworks. But with C you get a few library calls, you stay focused on the semantics of the language longer, and C often forces you to think harder and deeper about what’s happening under the hood.

C is a middle level language. When people talk about it you’ll hear phrases like “coding to the metal,” or “coding close to the wire.” C is the language of compilers, interpreters, editors, operating systems and embedded programming. When you learn to program in C you *almost have to gain an understanding of how programs execute*. You know what things like **register**, **stack**, **heap** and **memory mapped IO mean**. You start to think how much better life would have been if you had been born with sixteen fingers.

### Simplicity and speed

C is simple, elegant and wicked fast; it’s compact and efficient. Because C has **raw pointers**, **bitwise operators**, and the **keywords: extern, volatile, static, and register—meaning** you’ll understand more about writing efficient code than you can glean from any higher level language. The only thing that will teach you these things any better is a low level language, and with modern processors I wouldn’t wish assembler on anyone.

The C syntax is why programmers talk about the “C Family of Languages,” which generally includes languages like: C, C++, C#, Java, EcmaScript (aka JavaScript), Objective-C and many others. Wikipedia lists plenty more, but I think their list is a bit wacky.

### Discipline

C also happens to be demanding, fastidious, finicky and sometimes downright cryptic (*menuntut, rewel, rewel dan kadang-kadang benar-benar samar*). You can easily write hard-to-read, difficult to maintain code in C. But, and this is a key point, you don’t have to. Learning to write maintainable code in C will require (and hopefully instill) coding discipline. In most languages fixing syntax errors can border on the trivial (*sepele*). For instance, Ada’s compiler error messages are so good it might as well have just fixed the code for you. Finding and correcting a missing or additional semicolon in C can sometimes be an epic undertaking.

### Fewer distractions

**C is not an object oriented language** so you don’t get distracted (bingung) by things like inheritance and polymorphism. I’m not saying these aren’t important concepts, it’s just that you can simplify things a bit by learning straight procedural programming first. **In fact, once you've learned C, and written a couple of embedded programs on some single board computers, learning C++ is a natural next step**. You will need to get someone to pry your fingers off the macros and preprocessor directives but other than that it will be straightforward. I would be tempted to teach C with a C++ compiler, and just highlight the few differences that weren’t backwards compatible with a strict C compiler.

### Embedded programming

My final argument for learning C is tied to doing **embedded programming**. As a programmer I always get a sense of satisfaction when I deliver any working piece of code. Making a computer do what you want can be satisfying. But when I integrate my embedded code with some custom hardware that makes things happen outside of the computer—from moving a robotic arm to generating a precisely timed waveform—I get an incomparable thrill. **That thrill only happens because I learned C**. Of course, I ended up doing most of my embedded coding in C++ but I still felt that learning C first made it all possible. If you want a fast pleasant way to learn C, Pluralsight has you covered, check out Kenny Kerr’s [The C Programming Language in Action](https://www.pluralsight.com/courses/c-programming-language-in-action). 

